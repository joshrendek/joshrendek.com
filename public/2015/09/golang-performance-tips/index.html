<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8" />
<meta name="author" content="" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.25.1" />

<meta property="og:title" content="Golang Performance Tips" />
<meta property="og:description" content="Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k&#43;/second). Have any extra tips? Leave them in the comments!
Kernel Tuning Step 1 is making sure your host OS isn&rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.
Update /etc/sysctl.conf to have these lines:
net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://joshrendek.com/2015/09/golang-performance-tips/" />



<meta property="article:published_time" content="2015-09-20T21:30:07&#43;00:00"/>
<meta property="article:modified_time" content="2015-09-20T21:30:07&#43;00:00"/>













  <meta name="twitter:card" content="summary"/>



<meta name="twitter:text:title" content="Golang Performance Tips"/>
<meta name="twitter:title" content="Golang Performance Tips"/>
<meta name="twitter:description" content="Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k&#43;/second). Have any extra tips? Leave them in the comments!
Kernel Tuning Step 1 is making sure your host OS isn&rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.
Update /etc/sysctl.conf to have these lines:
net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net."/>




<meta itemprop="name" content="Golang Performance Tips">
<meta itemprop="description" content="Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k&#43;/second). Have any extra tips? Leave them in the comments!
Kernel Tuning Step 1 is making sure your host OS isn&rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.
Update /etc/sysctl.conf to have these lines:
net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.">


<meta itemprop="dateModified" content="2015-09-20T21:30:07&#43;00:00" />
<meta itemprop="wordCount" content="1003">



<meta itemprop="keywords" content="" />


<link rel="stylesheet" type="text/css" href="/css/layout.css" />
<link rel="stylesheet" type="text/css" href="/css/pygments.css" />
<link rel="stylesheet" type="text/css" href="/css/color-dark.css" />


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-3754808-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


<title>


     Golang Performance Tips 

</title>

<script src="/js/highlight.min.js"></script>
<link rel="stylesheet" href="/css/tomorrow-night.min.css" />
<script>hljs.initHighlightingOnLoad();</script>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://joshrendek.com">
        <span class='blue-brace'>{</span>
        Josh Rendek
        <span class='blue-brace'>}</span>
      </a>
      <div class="header-subtitle">
        <h2>
          <span class="heart">&lt;3</span> Ruby &amp; Go
        </h2>
      </div>
    </div> 
  </nav>
  <nav>
      
      
      <a class="nav-item" href="/"><div class="nav-item-title">Home</div></a>
      
      <a class="nav-item" href="/projects/"><div class="nav-item-title">Projects</div></a>
      
      <a class="nav-item" href="/archives/"><div class="nav-item-title">Archives</div></a>
      
      <a class="nav-item" href="https://devopsbyvideo.com/"><div class="nav-item-title">Screen Casts</div></a>
      
      <a class="nav-item" href="/about/"><div class="nav-item-title">About</div></a>
      
      <a class="nav-item" href="/categories/"><div class="nav-item-title">Categories</div></a>
      
      <a class="nav-item" href="https://github.com/joshrendek/"><div class="nav-item-title">GitHub</div></a>
      
      <a class="nav-item" href="/resume.pdf"><div class="nav-item-title">Resume</div></a>
      
   </nav>
</div>

  
<div class="social-links-header">

  

  

  

  

  

</div>


</header>


<main>
  <div class="articles">
    <article class="post">
      <div class="date"> Sep 20, 2015 - 5 minutes</div>
      <h1 class="title"> Golang Performance Tips </h1>
      <div class="content"> 

<p>Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k+/second). Have any extra tips? Leave them in the comments!</p>

<h2 id="kernel-tuning">Kernel Tuning</h2>

<p>Step 1 is making sure your host OS isn&rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.</p>

<p>Update <code>/etc/sysctl.conf</code> to have these lines:</p>

<pre><code class="language-bash">net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.ip_local_port_range = 50000
</code></pre>

<p><code>ip_local_port_range</code> - at the default of 30,000 and not modifying the <code>tw_reuse</code> and <code>tw_recycle</code> properties, we&rsquo;re effectively limited to 500 connections/second to a server. If this is still not enough you can configure additional IP&rsquo;s on the server and cycle between them.</p>

<p><code>tcp_tw_reuse</code> will re-use an existing connection that is in <code>TIME-WAIT</code> for outgoing connections.</p>

<p><code>tcp_tw_recycle</code> enables sockets to be recycled faster once they reach the <code>TIME-WAIT</code> state for both incoming and outgoing connections. Make sure you&rsquo;re not running anything through a NAT or this can cause problems with connections.</p>

<p><a href="http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html">Vinent Bernat</a> has a great explanation with state diagrams on his blog.</p>

<p>Next up are file descriptors. I prefer defining these in the init or upstart scripts, so you would call <code>ulimit -n 102400</code> and then call your go binary in the upstart script that way it is set before running. (Note: this will only work if the user has been properly given permissions to up their limit in <code>/etc/security/limits.d</code>.</p>

<p><a href="http://upstart.ubuntu.com/wiki/Stanzas#limit">Upstart</a> also provides a mechanism to set file limits in the job stanza.</p>

<h2 id="golang-tuning">Golang Tuning</h2>

<h3 id="utilizing-all-cpus-go-1-5">Utilizing all CPUs ( &lt; Go 1.5 )</h3>

<p>You can use all the go-routines in the world and not use all your CPU cores and threads. In order to let your go program utilize all operating-system level threads, we need to tell the go runtime about them:</p>

<pre><code class="language-go">runtime.GOMAXPROCS(runtime.NumCPU())
</code></pre>

<p>This is no longer necessary as of Go 1.5 and is done automatically.</p>

<h3 id="finish-what-you-start">Finish what you start</h3>

<p>Make sure you call <code>.Close()</code> on your responses, and make sure you read the entire body. The documentation for <code>net/http/response</code> explicitly says that &ldquo;it is the caller&rsquo;s responsibility to close Body&rdquo; and that &ldquo;neither ReadResponse nor Response.Write ever closes a connection.&rdquo; <a href="https://golang.org/src/net/http/response.go">net/http/response.go</a></p>

<h3 id="don-t-be-intimidated">Don&rsquo;t be intimidated</h3>

<p>You want to do things fast! But your confused by all the options for concurrency in go. Channels? Goroutines? Libraries to manage them? Stick with a simple worker pattern for best results. I&rsquo;ve found many libraries that claim to manage concurrency for you (limiting running routines, or providing some interface to queueing jobs) fall short, break, or not utilize all CPU cores.</p>

<p>Here is a simple worker pattern that uses nothing but the standard library:</p>

<pre><code class="language-go">tasks := make(chan someDataStruct, 40)
var wg sync.WaitGroup

for i := 0; i &lt; 40; i++ {
	wg.Add(1)
	go func() {
		for data := range tasks {
			// do some work on data
		}
		wg.Done()
	}()
}

// Push to it like this:
tasks &lt;- someData

// Finish like this
close(tasks)
wg.Wait()
</code></pre>

<p>First, we make a channel containing <code>someDataStruct</code> as the type to be sent/received over it. We give it a buffer size of 40. Since we only have 40 routines spinning up, no more than 40 can be worked on at once.</p>

<p>When a caller is trying to push data to this channel and all slots are full, it will block until a slot is free, so keep this in mind and change accordingly if you need to.</p>

<p>Next we make a <code>WaitGroup</code> which will wait for all of our goroutines to finish. When we loop 40 times and say <code>wg.Add(1)</code> we&rsquo;re telling the <code>WaitGroup</code> that we&rsquo;re expecting 40 goroutines, and to wait for them to finish.</p>

<p>Next we iterate over data coming in our <code>tasks</code> channel and do some process on it (this is obviously where your program specific logic or function calls go).</p>

<p>When no more data is available on the channel we call <code>wg.Done()</code> which tells the <code>WaitGroup</code> a routine has finished.</p>

<p>Pushing data is simple by passing an instance of <code>someDataStruct</code> into the <code>tasks</code> channel.</p>

<p>Almost done! We now want to wait for everything to finish before our program exits. <code>close(tasks)</code> marks the channel as closed - and any other callers who try and send to it will get a nice fat error message.</p>

<p>Finally <code>wg.Wait()</code> says to wait until all 40 <code>wg.Done()</code>&rsquo;s have been called.</p>

<h3 id="errors">Errors</h3>

<p>One of my favorite things about go is that its fast, real fast. Make sure you test, test, and test some more! Always make sure you fail gracefully (if a HTTP connection failed and you need to re-process a job, for instance) and push jobs back onto their queues when a failure is detected. If you have an unexpected race condition or other errors (run out of file descriptors, etc) go will very quickly churn through your job queue.</p>

<h3 id="but-what-about">But what about&hellip;</h3>

<p>There are lots of other considerations, like what you&rsquo;re running this against. On small elasticsearch clusters using these patterns to send data from go daemons to ES, I&rsquo;ve been able to hit 50k requests/second with still plenty of room to grow.</p>

<p>You may need to pay extra attention to what libraries your using: how many redis connections can you have open? How many do you need?</p>

<p>Are you using keep-alive connections for HTTP? Is your receiver setup properly (nginx configs, etc)?</p>

<p>Is your MySQL or PostgreSQL server tuned to allow this many connections? Make sure you use connection pooling!</p>

<h3 id="lastly-monitor-all-the-things">Lastly: Monitor all the things!</h3>

<p>Send your data somewhere. I prefer StatsD, InfluxDB and Grafana for my monitoring stack. There is a ready-to-use go library <a href="https://github.com/quipo/statsd">quipo/statsd</a> that I haven&rsquo;t had issues with. One important thing to do is throw any data sends into a goroutine otherwise you might notice a slowdown while it tries to send the data.</p>

<p>Whether you use Grafana or anything else, its important to monitor. Without metrics on how your systems are running (ops/s, latency, etc) you have no insight into whether or not new changes have affected the overall throughput of your system.</p>

<p>Have any extra tips? Leave them in the comments below!</p>
 </div>
      <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
</div>

  </div>

</footer>


  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'bluescripts';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>
  Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




    </article>
  </div>
  <div class="sidebar">
  <section>
    <h1>Projects & Software</h1>
    <ul>
      <li><a href="https://github.com/joshrendek/docker-conductor">Docker Conductor</a> is a docker orchestration tool.</li>
      <li><a href="http://sshpot.com/">sshpot.com</a> is a SSH honeypot service written in Go (both web service and client are open source).</li>
      <li><a href="http://ifcfg.net/">ifcfg.net</a> is a simple 'what is my IP' service with a few extra RESTful endpoints.</li>

      <li><a href="/projects/">View More</a>

      <li><a href="https://github.com/joshrendek?tab=repositories"><img src="/images/github.png" style='border: none;'> More on GitHub</a></li>
      <li><a href="https://rubygems.org/profiles/joshrendek">Gems @ RubyGems</a></li>
    </ul>
  </section>

  <section>
    <h1>Other Blogs</h1>
    <ul>
      <li><a href="http://tendermeatlove.com">Tender Meat Love</a> is my blog about cooking.</li>
      <li><a href="http://hydronerd.com">Hydro Nerd</a> is my blog about hydroponics and gardening.</li>
    </ul>
  </section>

  <section>
    <h1>Recent Posts</h1>
    <ul>
      
      <li><a href="https://joshrendek.com/2016/06/building-honeypots-and-analyzing-linux-malware/">Building honeypots and analyzing linux malware</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/understanding-elasticsearch-performance/">Understanding ElasticSearch Performance</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/">Building a distributed WaitGroup with Go and Redis</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/">Docker and ping: sendmsg: Operation not permitted</a></li>
      
      <li><a href="https://joshrendek.com/2015/10/influx-alert/">Influx Alert</a></li>
      
    </ul>
  </section>

</div>

</main>
  <footer>

  <div class="social-links-footer">

  

  

  

  

  

  <div class="social-link">
  <a href="https://joshrendek.com/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> Â© Copyright 2008-2017 Josh Rendek </div>

  </footer>

</body>
</html>

