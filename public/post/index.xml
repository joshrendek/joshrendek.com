<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Josh Rendek</title>
    <link>https://joshrendek.com/post/</link>
    <description>Recent content in Posts on Josh Rendek</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright 2008-2017 Josh Rendek</copyright>
    <lastBuildDate>Thu, 30 Jun 2016 21:53:08 +0000</lastBuildDate>
    
	<atom:link href="https://joshrendek.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building honeypots and analyzing linux malware</title>
      <link>https://joshrendek.com/2016/06/building-honeypots-and-analyzing-linux-malware/</link>
      <pubDate>Thu, 30 Jun 2016 21:53:08 +0000</pubDate>
      
      <guid>https://joshrendek.com/2016/06/building-honeypots-and-analyzing-linux-malware/</guid>
      <description>I’ve been running https://sshpot.com/ for a while now - and decided it needed to be revamped and overhauled - and thought I’d make a presentation and write up some details on the process as well. If you&amp;rsquo;d like to just view the slides, hop over here.
If you&amp;rsquo;re just looking for the source code:
 Web application  https://github.com/joshrendek/ssh-passwd-honeypot  Honeypot Server  https://github.com/joshrendek/sshpot-com   Table of Contents  Design Goals  Appearing More Vulnerable Correlating Sessions &amp;amp; Commands Proxying Requests &amp;amp; Capturing Data  Handling Requests Simulating Commands Persistence Layer Analyzing Dropped Files  Trojan-DDoS.</description>
    </item>
    
    <item>
      <title>Understanding ElasticSearch Performance</title>
      <link>https://joshrendek.com/2015/11/understanding-elasticsearch-performance/</link>
      <pubDate>Thu, 26 Nov 2015 12:05:13 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/11/understanding-elasticsearch-performance/</guid>
      <description>Performance before and after Optimizations When working with billions of documents in your Elasticsearch cluster, there are a few important things to keep in mind:
 Look at what the big players do (Elasticsearch/Kibana) for organization and planning Experiment with index sizes that make sense for your business, don&amp;rsquo;t just assume 1 index for a billion documents is a good idea (even if you N shards) Understand which metrics to monitor when you are performance testing your cluster Monitor all points of ingestion: Elasticsearch, Load balancers (ELB, HAProxy, etc), and your application code that is inserting  What do the big players do?</description>
    </item>
    
    <item>
      <title>Building a distributed WaitGroup with Go and Redis</title>
      <link>https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/</link>
      <pubDate>Sun, 08 Nov 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/</guid>
      <description>If you&amp;rsquo;ve done any concurrency work in Go you&amp;rsquo;ve used WaitGroups. They&amp;rsquo;re awesome!
Now lets say you have a bunch of workers that do some stuff, but at some point they all need to hit a single API that your rate limited against.
You could move to just using a single process and limiting it that way, but that doesn&amp;rsquo;t scale out very well.
While there are quite a few distributed lock libraries in Go, I didn&amp;rsquo;t find any that worked similarly to WaitGroups, so I set out to write one.</description>
    </item>
    
    <item>
      <title>Docker and ping: sendmsg: Operation not permitted</title>
      <link>https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/</link>
      <pubDate>Mon, 02 Nov 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/</guid>
      <description>You&amp;rsquo;ve raised your file descriptor limits, updated security limits, tweaked your network settings and done everything else in preperation to launch your shiny new dockerized application.
Then you have performance issues and you can&amp;rsquo;t understand why, it looks to be network related. Alright! Let&amp;rsquo;s see what&amp;rsquo;s going on:
ping google.com unknown host google.com  Maybe its DNS related&amp;hellip;. Let&amp;rsquo;s try again:
ping 8.8.8.8 ping: sendmsg: Operation not permitted  That&amp;rsquo;s odd, maybe it&amp;rsquo;s a networking issue outside of our servers.</description>
    </item>
    
    <item>
      <title>Influx Alert</title>
      <link>https://joshrendek.com/2015/10/influx-alert/</link>
      <pubDate>Mon, 12 Oct 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/10/influx-alert/</guid>
      <description>I&amp;rsquo;ve been very happy using InfluxDB with Grafana + StatsD but always wanted a nice way to alert on some of the data being fed into statsd/grafana so I wrote a little tool in Go to accomplish that:
Github: https://github.com/joshrendek/influx-alert
I hope someone finds this useful! It&amp;rsquo;s got a few simple functions/comparisons done already and support for HipChat and Slack notifications.
Documentation Influx Alert This is a tool to alert on data that is fed into InfluxDB (for example, via statsd) so you can get alerted on it.</description>
    </item>
    
    <item>
      <title>Getting upstart to log to syslog with tags</title>
      <link>https://joshrendek.com/2015/09/getting-upstart-to-log-to-syslog-with-tags/</link>
      <pubDate>Wed, 23 Sep 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/09/getting-upstart-to-log-to-syslog-with-tags/</guid>
      <description>I was setting up the ELK stack and had quite a fun time trying to get upstart to log to syslog WITH a log tag ( aka: my-application ) so it could be filtered inside Kibana.
Here is a working example for STDOUT and STDERR:
respawn respawn limit 15 5 start on runlevel [2345] stop on runlevel [06] setuid app-user setgid app-user script # Redirect stdout to syslog mkfifo /tmp/app-stdout-fifo ( logger -p user.</description>
    </item>
    
    <item>
      <title>Golang Performance Tips</title>
      <link>https://joshrendek.com/2015/09/golang-performance-tips/</link>
      <pubDate>Sun, 20 Sep 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/09/golang-performance-tips/</guid>
      <description>Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k+/second). Have any extra tips? Leave them in the comments!
Kernel Tuning Step 1 is making sure your host OS isn&amp;rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.
Update /etc/sysctl.conf to have these lines:
net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.</description>
    </item>
    
    <item>
      <title>Using a custom HTTP Dialer in Go</title>
      <link>https://joshrendek.com/2015/09/using-a-custom-http-dialer-in-go/</link>
      <pubDate>Sat, 19 Sep 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/09/using-a-custom-http-dialer-in-go/</guid>
      <description>Let&amp;rsquo;s make a function to generate an HTTP client for us using a custom dialer:
1 var DefaultDialer = &amp;amp;net.Dialer{} 2  3 func GetHttpClient() http.Client { 4 	tr := &amp;amp;http.Transport{ 5 	Dial: DefaultDialer.Dial, 6 	} 7  8 	client := http.Client{Transport: tr} 9 	return client 10 }  Can you spot the bug?
By omitting the Timeout, KeepAlive timeouts in the first example, we&amp;rsquo;ve introduced a very subtle bug.</description>
    </item>
    
    <item>
      <title>Faster docker builds using a cache</title>
      <link>https://joshrendek.com/2015/06/faster-docker-builds-using-a-cache/</link>
      <pubDate>Wed, 17 Jun 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/06/faster-docker-builds-using-a-cache/</guid>
      <description>If you&amp;rsquo;re using bundler for your ruby or rails project and docker you will run into docker having to install your gems everytime. You can either make a base image that has the bundle cache already on it, or you can make a small cache step in your Dockerfile.
Here I&amp;rsquo;ve setup a cache user and host to store the cache tar. It will attempt to download and untar it, run bundle, then attempt to tar and re-upload it.</description>
    </item>
    
    <item>
      <title>Communication between React components using events</title>
      <link>https://joshrendek.com/2015/02/communication-between-react-components-using-events/</link>
      <pubDate>Sat, 21 Feb 2015 10:20:39 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/02/communication-between-react-components-using-events/</guid>
      <description>Here is an example of a clean way to communicate between React components without getting stuck passing @prop callbacks all around. Inspired by looking at the new Flux React utilities.
We&amp;rsquo;re going to start off with a simple HAML file:
1 %script{src: &amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.12.2/react-with-addons.js&amp;quot;} 2 %div{data: { ui: &amp;#39;alerts&amp;#39; }} 3 %div{data: { ui: &amp;#39;widgets&amp;#39; }} 4 :javascript 5  React.renderComponent(Widgets(), document.querySelector(&amp;#39;[data-ui=&amp;quot;widgets&amp;quot;]&amp;#39;)) 6  React.renderComponent(Alerts(), document.querySelector(&amp;#39;[data-ui=&amp;quot;alerts&amp;quot;]&amp;#39;))  Next comes our Widget component.</description>
    </item>
    
    <item>
      <title>Starting out with hydroponics</title>
      <link>https://joshrendek.com/2014/09/starting-out-with-hydroponics/</link>
      <pubDate>Sun, 14 Sep 2014 12:02:21 +0000</pubDate>
      
      <guid>https://joshrendek.com/2014/09/starting-out-with-hydroponics/</guid>
      <description>Moved to my new hydroponics website: http://hydronerd.com/</description>
    </item>
    
    <item>
      <title>Rails force HTTPS for your application</title>
      <link>https://joshrendek.com/2014/08/rails-force-https-for-your-application/</link>
      <pubDate>Fri, 22 Aug 2014 10:57:37 +0000</pubDate>
      
      <guid>https://joshrendek.com/2014/08/rails-force-https-for-your-application/</guid>
      <description>This is your setup:  Nginx redirecting HTTP to HTTPS Unicorn/puma/(etc) being reverse proxied to via nginx  What you may not realize: When you&amp;rsquo;re submitting a form and using the redirect_to or respond_with @object, location: [] methods rails may not pick up that you want to use HTTPS as the protocol, adding this to your application_controller.rb ensures every URL generated by rails will go to a secure protocol:</description>
    </item>
    
    <item>
      <title>Go-lang compare *ssh.Request.Type against a string</title>
      <link>https://joshrendek.com/2014/07/go-lang-compare-star-ssh-dot-request-dot-type-against-a-string/</link>
      <pubDate>Tue, 08 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://joshrendek.com/2014/07/go-lang-compare-star-ssh-dot-request-dot-type-against-a-string/</guid>
      <description>I was working on the agent for SSH Pot and ran into something interesting last night. A lot of the brute force attempts attempt to run a command like this:
ssh user@host &#39;uname&#39;  This is different than:
ssh user@host $ uname  The first command is executing a command then exiting, the second is actually logging in and giving the user a shell. The first requests a exec subsystem and the second requests a shell subsystem - so there are two ways to handle it.</description>
    </item>
    
    <item>
      <title>Go-lang: mocking exec.Command using interfaces</title>
      <link>https://joshrendek.com/2014/06/go-lang-mocking-exec-dot-command-using-interfaces/</link>
      <pubDate>Wed, 18 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://joshrendek.com/2014/06/go-lang-mocking-exec-dot-command-using-interfaces/</guid>
      <description>This is a short example showing how to use an interface to ease testing, and how to use an interface with running shell commands / other programs and providing mock output.
 Source on Github 
Here is our main file that actually runs the commands and prints out &amp;ldquo;hello&amp;rdquo;.
1 package main 2  3 import ( 4 	&amp;quot;fmt&amp;quot; 5 	&amp;quot;os/exec&amp;quot; 6 ) 7  8 // first argument is the command, like cat or echo, 9 // the second is the list of args to pass to it 10 type Runner interface { 11 	Run(string, .</description>
    </item>
    
    <item>
      <title>A useful logger in Go</title>
      <link>https://joshrendek.com/2014/06/a-useful-logger-in-go/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://joshrendek.com/2014/06/a-useful-logger-in-go/</guid>
      <description>Small function that will print out useful information when invoked:
1 func logMsg(msg string) { 2 	pc, _, _, _ := runtime.Caller(1) 3 	caller := runtime.FuncForPC(pc).Name() 4 	_, file, line, _ := runtime.Caller(0) 5 	sp := strings.Split(file, &amp;quot;/&amp;quot;) 6 	short_path := sp[len(sp)-2 : len(sp)] 7 	path_line := fmt.Sprintf(&amp;quot;[%s/%s:%d]&amp;quot;, short_path[0], short_path[1], line) 8 	log_string := fmt.Sprintf(&amp;quot;[%s]%s %s:: %s&amp;quot;, time.Now(), path_line, caller, msg) 9 	fmt.</description>
    </item>
    
  </channel>
</rss>