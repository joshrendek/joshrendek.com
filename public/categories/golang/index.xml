<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Josh Rendek</title>
    <link>https://joshrendek.com/categories/golang/</link>
    <description>Recent content in Golang on Josh Rendek</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© Copyright 2008-2017 Josh Rendek</copyright>
    <lastBuildDate>Sun, 08 Nov 2015 21:30:07 +0000</lastBuildDate>
    
	<atom:link href="https://joshrendek.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building a distributed WaitGroup with Go and Redis</title>
      <link>https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/</link>
      <pubDate>Sun, 08 Nov 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/</guid>
      <description>If you&amp;rsquo;ve done any concurrency work in Go you&amp;rsquo;ve used WaitGroups. They&amp;rsquo;re awesome!
Now lets say you have a bunch of workers that do some stuff, but at some point they all need to hit a single API that your rate limited against.
You could move to just using a single process and limiting it that way, but that doesn&amp;rsquo;t scale out very well.
While there are quite a few distributed lock libraries in Go, I didn&amp;rsquo;t find any that worked similarly to WaitGroups, so I set out to write one.</description>
    </item>
    
    <item>
      <title>Docker and ping: sendmsg: Operation not permitted</title>
      <link>https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/</link>
      <pubDate>Mon, 02 Nov 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/</guid>
      <description>You&amp;rsquo;ve raised your file descriptor limits, updated security limits, tweaked your network settings and done everything else in preperation to launch your shiny new dockerized application.
Then you have performance issues and you can&amp;rsquo;t understand why, it looks to be network related. Alright! Let&amp;rsquo;s see what&amp;rsquo;s going on:
ping google.com unknown host google.com  Maybe its DNS related&amp;hellip;. Let&amp;rsquo;s try again:
ping 8.8.8.8 ping: sendmsg: Operation not permitted  That&amp;rsquo;s odd, maybe it&amp;rsquo;s a networking issue outside of our servers.</description>
    </item>
    
    <item>
      <title>Influx Alert</title>
      <link>https://joshrendek.com/2015/10/influx-alert/</link>
      <pubDate>Mon, 12 Oct 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/10/influx-alert/</guid>
      <description>I&amp;rsquo;ve been very happy using InfluxDB with Grafana + StatsD but always wanted a nice way to alert on some of the data being fed into statsd/grafana so I wrote a little tool in Go to accomplish that:
Github: https://github.com/joshrendek/influx-alert
I hope someone finds this useful! It&amp;rsquo;s got a few simple functions/comparisons done already and support for HipChat and Slack notifications.
Documentation Influx Alert This is a tool to alert on data that is fed into InfluxDB (for example, via statsd) so you can get alerted on it.</description>
    </item>
    
    <item>
      <title>Golang Performance Tips</title>
      <link>https://joshrendek.com/2015/09/golang-performance-tips/</link>
      <pubDate>Sun, 20 Sep 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/09/golang-performance-tips/</guid>
      <description>Below is some advice and notes that I wish I had when writing Go to deal with high amounts of requests (20k+/second). Have any extra tips? Leave them in the comments!
Kernel Tuning Step 1 is making sure your host OS isn&amp;rsquo;t going to keel over when you start making thousands of requests/second or hammering the CPU.
Update /etc/sysctl.conf to have these lines:
net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.</description>
    </item>
    
    <item>
      <title>Using a custom HTTP Dialer in Go</title>
      <link>https://joshrendek.com/2015/09/using-a-custom-http-dialer-in-go/</link>
      <pubDate>Sat, 19 Sep 2015 21:30:07 +0000</pubDate>
      
      <guid>https://joshrendek.com/2015/09/using-a-custom-http-dialer-in-go/</guid>
      <description>Let&amp;rsquo;s make a function to generate an HTTP client for us using a custom dialer:
1 var DefaultDialer = &amp;amp;net.Dialer{} 2  3 func GetHttpClient() http.Client { 4 	tr := &amp;amp;http.Transport{ 5 	Dial: DefaultDialer.Dial, 6 	} 7  8 	client := http.Client{Transport: tr} 9 	return client 10 }  Can you spot the bug?
By omitting the Timeout, KeepAlive timeouts in the first example, we&amp;rsquo;ve introduced a very subtle bug.</description>
    </item>
    
  </channel>
</rss>