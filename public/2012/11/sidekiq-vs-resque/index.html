<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8" />
<meta name="author" content="" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.25.1" />

<meta property="og:title" content="Sidekiq vs Resque, with MRI and JRuby" />
<meta property="og:description" content="Before we dive into the benchmarks of Resque vs Sidekiq it will first help to have a better understanding of how forking and threading works in Ruby.
Threading vs Forking Forking When you fork a process you are creating an entire copy of that process: the address space and all open file descriptors. You get a separate copy of the address space of the parent process, isolating any work done to that fork." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://joshrendek.com/2012/11/sidekiq-vs-resque/" />



<meta property="article:published_time" content="2012-11-03T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2012-11-03T00:00:00&#43;00:00"/>













  <meta name="twitter:card" content="summary"/>



<meta name="twitter:text:title" content="Sidekiq vs Resque, with MRI and JRuby"/>
<meta name="twitter:title" content="Sidekiq vs Resque, with MRI and JRuby"/>
<meta name="twitter:description" content="Before we dive into the benchmarks of Resque vs Sidekiq it will first help to have a better understanding of how forking and threading works in Ruby.
Threading vs Forking Forking When you fork a process you are creating an entire copy of that process: the address space and all open file descriptors. You get a separate copy of the address space of the parent process, isolating any work done to that fork."/>




<meta itemprop="name" content="Sidekiq vs Resque, with MRI and JRuby">
<meta itemprop="description" content="Before we dive into the benchmarks of Resque vs Sidekiq it will first help to have a better understanding of how forking and threading works in Ruby.
Threading vs Forking Forking When you fork a process you are creating an entire copy of that process: the address space and all open file descriptors. You get a separate copy of the address space of the parent process, isolating any work done to that fork.">


<meta itemprop="dateModified" content="2012-11-03T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1968">



<meta itemprop="keywords" content="" />


<link rel="stylesheet" type="text/css" href="/css/layout.css" />
<link rel="stylesheet" type="text/css" href="/css/pygments.css" />
<link rel="stylesheet" type="text/css" href="/css/color-dark.css" />


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-3754808-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


<title>


     Sidekiq vs Resque, with MRI and JRuby 

</title>

<script src="/js/highlight.min.js"></script>
<link rel="stylesheet" href="/css/tomorrow-night.min.css" />
<script>hljs.initHighlightingOnLoad();</script>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://joshrendek.com">
        <span class='blue-brace'>{</span>
        Josh Rendek
        <span class='blue-brace'>}</span>
      </a>
      <div class="header-subtitle">
        <h2>
          <span class="heart">&lt;3</span> Ruby &amp; Go
        </h2>
      </div>
    </div> 
  </nav>
  <nav>
      
      
      <a class="nav-item" href="/"><div class="nav-item-title">Home</div></a>
      
      <a class="nav-item" href="/projects/"><div class="nav-item-title">Projects</div></a>
      
      <a class="nav-item" href="/archives/"><div class="nav-item-title">Archives</div></a>
      
      <a class="nav-item" href="https://devopsbyvideo.com/"><div class="nav-item-title">Screen Casts</div></a>
      
      <a class="nav-item" href="/about/"><div class="nav-item-title">About</div></a>
      
      <a class="nav-item" href="/categories/"><div class="nav-item-title">Categories</div></a>
      
      <a class="nav-item" href="https://github.com/joshrendek/"><div class="nav-item-title">GitHub</div></a>
      
      <a class="nav-item" href="/resume.pdf"><div class="nav-item-title">Resume</div></a>
      
   </nav>
</div>

  
<div class="social-links-header">

  

  

  

  

  

</div>


</header>


<main>
  <div class="articles">
    <article class="post">
      <div class="date"> Nov 3, 2012 - 10 minutes</div>
      <h1 class="title"> Sidekiq vs Resque, with MRI and JRuby </h1>
      <div class="content"> 

<p>Before we dive into the benchmarks of Resque vs Sidekiq it will first help to have a better understanding of how forking and threading works in Ruby.</p>

<h1 id="threading-vs-forking">Threading vs Forking</h1>

<h2 id="forking">Forking</h2>

<p>When you fork a process you are creating an entire copy of that process: the address space and all open file descriptors. You get a separate copy of the address space of the parent process, isolating any work done to that fork. If the forked child process does a lot of work and uses a lot of memory, when that child exits the memory gets free&rsquo;d back to the operating system. If your programming language (MRI Ruby) doesn&rsquo;t support actual kernel level threading, then this is the only way to spread work out across multiple cores since each process will get scheduled to a different core. You also gain some stability since if a child crashes the parent can just respawn a new fork, however there is a caveat. If the parent dies while there are children that haven&rsquo;t exited, then those children become zombies.</p>

<h3 id="forking-and-ruby">Forking and Ruby</h3>

<p>One important note about forking with Ruby is that the maintainers have done a good job on keeping memory usage down when forking. Ruby implements a copy on write system for memory allocation with child forks.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="lineno"> 1 </span><span class="nb">require</span> <span class="s1">&#39;benchmark&#39;</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span><span class="n">fork_pids</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 4 </span>
<span class="lineno"> 5 </span><span class="c1"># Lets fill up some memory</span>
<span class="lineno"> 6 </span>
<span class="lineno"> 7 </span><span class="n">objs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="lineno"> 8 </span><span class="n">objs</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 9 </span><span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">10 </span>  <span class="n">objs</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">11 </span><span class="k">end</span>
<span class="lineno">12 </span>
<span class="lineno">13 </span>
<span class="lineno">14 </span>
<span class="lineno">15 </span><span class="mi">50</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">16 </span>    <span class="n">fork_pids</span> <span class="o">&lt;&lt;</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="k">do</span>
<span class="lineno">17 </span>        <span class="nb">sleep</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
<span class="lineno">18 </span>    <span class="k">end</span>
<span class="lineno">19 </span><span class="k">end</span>
<span class="lineno">20 </span><span class="n">fork_pids</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="no">Process</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span> <span class="p">}</span>
<span class="lineno">21 </span><span class="p">}</span>
</code></pre></div>


<p>We can see this in action here:</p>


<figure >
    
        <img src="/images/showdown/copy_on_write.png" />
    
    
</figure>


<p>However when we start modifying memory inside the child forks, memory quickly grows.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="lineno">1 </span><span class="mi">50</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">2 </span>    <span class="n">fork_pids</span> <span class="o">&lt;&lt;</span> <span class="no">Process</span><span class="o">.</span><span class="n">fork</span> <span class="k">do</span>
<span class="lineno">3 </span>      <span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">4 </span>        <span class="n">objs</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">5 </span>      <span class="k">end</span>
<span class="lineno">6 </span>    <span class="k">end</span>
<span class="lineno">7 </span><span class="k">end</span>
<span class="lineno">8 </span><span class="n">fork_pids</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="no">Process</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="nb">p</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div>


<p>We&rsquo;re now creating a million new objects in each forked child:</p>


<figure >
    
        <img src="/images/showdown/forced_copy_on_write.png" />
    
    
</figure>


<h2 id="threading">Threading</h2>

<p>Threads on the other hand have considerably less overhead since they share address space, memory, and allow easier communication (versus inter-process communication with forks). Context switching between threads inside the same process is also generally cheaper than scheduling switches between processes. Depending on the runtime being used, any issues that might occur using threads (for instance needing to use lots of memory for a task) can be handled by the garbage collector for the most part. One of the benefits of threading is that you do not have to worry about zombie processes since all threads die when the process dies, avoiding the issue of zombies.</p>

<h2 id="threading-with-ruby">Threading with Ruby</h2>

<p>As of 1.9 the GIL (Global Interpreter Lock) is gone! But it&rsquo;s only been renamed to the GVL (Global VM Lock). The GVL in MRI ruby uses a lock called <code>rb_thread_lock_t</code> which is a mutex around when ruby code can be run. When no ruby objects are being touched, you can actually run ruby threads in parallel before the GVL kicks in again (ie: system level blocking call, IO blocking outside of ruby). After these blocking calls each thread checks the interrupt <code>RUBY_VM_CHECK_INTS</code>.</p>

<p>With MRI ruby threads are pre-emptively scheduled using a function called <code>rb_thread_schedule</code> which schedules an &ldquo;interrupt&rdquo; that lets each thread get a fair amount of execution time (every 10 microseconds). <a href="http://svn.ruby-lang.org/cgi-bin/viewvc.cgi/trunk/thread.c?view=markup">[source: thread.c:1018]</a></p>

<p>We can see an example of the GIL/GVL in action here:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="lineno"> 1 </span><span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span><span class="n">objs</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 4 </span><span class="n">objs</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 5 </span><span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno"> 6 </span>  <span class="n">objs</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno"> 7 </span><span class="k">end</span>
<span class="lineno"> 8 </span>
<span class="lineno"> 9 </span><span class="mi">50</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span>
<span class="lineno">10 </span>  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
<span class="lineno">11 </span>    <span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">12 </span>      <span class="n">objs</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">13 </span>    <span class="k">end</span>
<span class="lineno">14 </span>  <span class="k">end</span>
<span class="lineno">15 </span><span class="k">end</span>
<span class="lineno">16 </span>
<span class="lineno">17 </span><span class="n">threads</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div>


<p>Normally this would be an unsafe operation, but since the GIL/GVL exists we don&rsquo;t have to worry about two threads adding to the same ruby object at once since only one thread can run on the VM at once and it ends up being an atomic operation <em>(although don&rsquo;t rely on this quirk for thread safety, it definitely doesn&rsquo;t apply to any other VMs)</em>.</p>

<p>Another important note is that the Ruby GC is doing a really horrible job during this benchmark.</p>


<figure >
    
        <img src="/images/showdown/threading_leak.png" />
    
    
</figure>


<p>The memory kept growing so I had to kill the process after a few seconds.</p>

<h2 id="threading-with-jruby-on-the-jvm">Threading with JRuby on the JVM</h2>

<p>JRuby specifies the use of native threads based on the operating system support using the <code>getNativeThread</code> call <a href="https://github.com/jruby/jruby/blob/master/src/org/jruby/RubyThread.java#L216">[2]</a>. JRuby&rsquo;s implementation of threads using the JVM means there is no GIL/GVL. This allows CPU bound processes to utilize all cores of a machine without having to deal with forking (which, in the case of resque, can be <em>very</em> expensive).</p>

<p>When trying to execute the GIL safe code above JRuby spits out a concurrency error: <code>ConcurrencyError: Detected invalid array contents due to unsynchronized modifications with concurrent users</code></p>

<p>We can either add a mutex around this code or modify it to not worry about concurrent access. I chose the latter:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="lineno"> 1 </span><span class="n">threads</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 2 </span>
<span class="lineno"> 3 </span><span class="n">objs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="lineno"> 4 </span><span class="n">objs</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span>
<span class="lineno"> 5 </span><span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno"> 6 </span>  <span class="n">objs</span><span class="o">[</span><span class="s1">&#39;test&#39;</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno"> 7 </span><span class="k">end</span>
<span class="lineno"> 8 </span>
<span class="lineno"> 9 </span><span class="mi">50</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span>
<span class="lineno">10 </span>  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
<span class="lineno">11 </span>    <span class="mi">1_000_000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
<span class="lineno">12 </span>      <span class="n">objs</span><span class="o">[</span><span class="n">num</span><span class="o">]</span> <span class="o">=</span> <span class="o">[]</span> <span class="k">if</span> <span class="n">objs</span><span class="o">[</span><span class="n">num</span><span class="o">].</span><span class="n">nil?</span>
<span class="lineno">13 </span>      <span class="n">objs</span><span class="o">[</span><span class="n">num</span><span class="o">]</span> <span class="o">&lt;&lt;</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">14 </span>    <span class="k">end</span>
<span class="lineno">15 </span>  <span class="k">end</span>
<span class="lineno">16 </span><span class="k">end</span>
<span class="lineno">17 </span>
<span class="lineno">18 </span><span class="n">threads</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div>


<p>Compared to the MRI version, ruby running on the JVM was able to make some optimizations and keep memory usage around 800MB for the duration of the test:</p>


<figure >
    
        <img src="/images/showdown/jvm_threading.png" />
    
    
</figure>


<p>Now that we have a better understanding of the differences between forking and threading in Ruby, lets move on to Sidekiq and Resque.</p>

<h1 id="sidekiq-and-resque">Sidekiq and Resque</h1>

<h2 id="resque-s-view-of-the-world">Resque&rsquo;s view of the world</h2>

<p>Resque assumes chaos in your environment. It follows the forking model with C and ruby and makes a complete copy of each resque parent when a new job needs to be run. This has its advantages in preventing memory leaks, long running workers, and locking. You run into an issue with forking though when you need to increase the amount of workers on a machine. You end up not having enough spare CPU cycles since the majority are being taken up handling all the forking.</p>

<p>Resque follows a simple fork and do work model, each worker will take a job off the queue and fork a new process to do the job.</p>

<p><a href="https://github.com/defunkt/resque">Resque @ Github</a></p>

<h2 id="sidekiq-s-view-of-the-world">Sidekiq&rsquo;s view of the world</h2>

<p>Unlike Resque, Sidekiq uses threads and is extremely easy to use as a drop in replacement to Resque since they both work on the same <code>perform</code> method. When you dig into the results below you can see that Sidekiq&rsquo;s claim of being able to handle a larger number of workers and amount of work is true. Due to using threads and not having to allocate a new stack and address space for each fork, you get that overhead back and are able to do more work with a threaded model.</p>

<p>Sidekiq follows the actor pattern. So compared to Resque which has N workers that fork, Sidekiq has an Actor manager, with N threads and one Fetcher actor which will pop jobs off Redis and hand them to the Manager. Sidekiq handles the &ldquo;chaos&rdquo; portion of Resque by catching all exceptions and bubbling them up to an exception handler such as Airbrake or Errbit.</p>

<p>Now that we know how Sidekiq and Resque work we can get on to testing them and comparing the results.</p>

<p><a href="https://github.com/mperham/sideki://github.com/mperham/sidekiq">Sidekiq @ Github</a></p>

<h1 id="the-test-code">The Test Code</h1>

<p>The idea behind the test was to pick a CPU bound processing task, in this case SHA256 and apply it across a set of 20 numbers, 150,000 times.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="lineno"> 1 </span><span class="nb">require</span> <span class="s1">&#39;sidekiq&#39;</span>
<span class="lineno"> 2 </span><span class="nb">require</span> <span class="s1">&#39;resque&#39;</span>
<span class="lineno"> 3 </span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>
<span class="lineno"> 4 </span>
<span class="lineno"> 5 </span>
<span class="lineno"> 6 </span><span class="c1"># Running:</span>
<span class="lineno"> 7 </span><span class="c1"># sidekiq -r ./por.rb -c 240</span>
<span class="lineno"> 8 </span><span class="c1">#</span>
<span class="lineno"> 9 </span><span class="c1"># require &#39;sidekiq&#39;</span>
<span class="lineno">10 </span><span class="c1"># require &#39;./por&#39;</span>
<span class="lineno">11 </span><span class="c1"># queueing: 150_000.times { Sidekiq::Client.enqueue(POR, [rand(123098)]*20) }</span>
<span class="lineno">12 </span><span class="c1"># queueing: 150_000.times { Resque.enqueue(POR, [rand(123098)]*20) }</span>
<span class="lineno">13 </span>
<span class="lineno">14 </span><span class="k">class</span> <span class="nc">POR</span>
<span class="lineno">15 </span>  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
<span class="lineno">16 </span>
<span class="lineno">17 </span>  <span class="vi">@queue</span> <span class="o">=</span> <span class="ss">:por</span>
<span class="lineno">18 </span>
<span class="lineno">19 </span>  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="lineno">20 </span>    <span class="n">arr</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
<span class="lineno">21 </span>      <span class="no">Digest</span><span class="o">::</span><span class="no">SHA2</span><span class="o">.</span><span class="n">new</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">to_s</span>
<span class="lineno">22 </span>    <span class="k">end</span>
<span class="lineno">23 </span>  <span class="k">end</span>
<span class="lineno">24 </span>
<span class="lineno">25 </span>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">perform</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="lineno">26 </span>    <span class="n">arr</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
<span class="lineno">27 </span>      <span class="no">Digest</span><span class="o">::</span><span class="no">SHA2</span><span class="o">.</span><span class="n">new</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">to_s</span>
<span class="lineno">28 </span>    <span class="k">end</span>
<span class="lineno">29 </span>  <span class="k">end</span>
<span class="lineno">30 </span>
<span class="lineno">31 </span><span class="k">end</span>
</code></pre></div>


<h1 id="test-machine">Test Machine</h1>

<pre><code>      Model Name: Mac Pro
      Model Identifier: MacPro4,1
      Processor Name: Quad-Core Intel Xeon
      Processor Speed: 2.26 GHz
      Number of Processors: 2
      Total Number of Cores: 8
      L2 Cache (per Core): 256 KB
      L3 Cache (per Processor): 8 MB
      Memory: 12 GB
      Processor Interconnect Speed: 5.86 GT/s
</code></pre>

<p>This gives us a total of 16 cores to use for our testing. I&rsquo;m also using a <a href="http://www.amazon.com/gp/product/B004W2JKZI/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B004W2JKZI&amp;linkCode=as2&amp;tag=josren-20">Crucial M4 SSD</a></p>

<h1 id="results">Results</h1>

<h2 id="time-to-process-150-000-sets-of-20-numbers">Time to Process 150,000 sets of 20 numbers</h2>


<figure >
    
        <img src="/images/showdown/time_to_process.png" />
    
    
</figure>


<p><center>
<table width="100%" style="text-align: center;">
<tr>
<td><strong>Type</strong></td><td><strong>Time to Completion (seconds)</strong></td>
</tr>
<tr>
<td>Sidekiq (JRuby) 150 Threads</td><td>88</td>
</tr>
<tr>
<td>Sidekiq (JRuby) 240 Threads</td><td>89</td>
</tr>
<tr>
<td>Sidekiq (JRuby) 50 Threads</td><td>91</td>
</tr>
<tr>
<td>Sidekiq (MRI) 5x50</td><td>98</td>
</tr>
<tr>
<td>Sidekiq (MRI) 3x50</td><td>120</td>
</tr>
<tr>
<td>Sidekiq (MRI) 50</td><td>312</td>
</tr>
<tr>
<td>Resque 50</td><td>396</td>
</tr>
</table>
</center></p>

<hr>

<h2 id="all-about-the-cpu">All about the CPU</h2>

<h3 id="resque-50-workers">Resque: 50 workers</h3>


<figure >
    
        <img src="/images/showdown/resque_50.png" />
    
    
</figure>


<p>Here we can see that the forking is taking its toll on the available CPU we have for processing. Roughly 50% of the CPU is being wasted on forking and scheduling those new processes. Resque took 396 seconds to finish and process 150,000 jobs.</p>

<h3 id="sidekiq-mri-1-process-50-threads">Sidekiq (MRI) 1 process, 50 threads</h3>


<figure >
    
        <img src="/images/showdown/mri_50.png" />
    
    
</figure>


<p>We&rsquo;re not fully utilizing the CPU. When running this test it pegged one CPU at 100% usage and kept it there for the duration of the test. We have a slight overhead with system CPU usage. Sidekiq took 312 seconds with 50 threads using MRI Ruby. Lets now take a look at doing things a bit resque-ish, and use multiple sidekiq processes to get more threads scheduled across multiple CPUs.</p>

<h3 id="sidekiq-mri-3-processes-50-threads">Sidekiq (MRI) 3 processes, 50 threads</h3>


<figure >
    
        <img src="/images/showdown/mri_3x50.png" />
    
    
</figure>


<p>We&rsquo;re doing better. We&rsquo;ve cut our processing time roughly in third and we&rsquo;re utilizing more of our resources (CPUs). 3 Sidekiq processes with 50 threads each (for a total of 150 threads) took 120 seconds to complete 150,000 jobs.</p>

<h3 id="sidekiq-mri-5-processes-50-threads">Sidekiq (MRI) 5 processes, 50 threads</h3>


<figure >
    
        <img src="/images/showdown/mri_5x50.png" />
    
    
</figure>


<p>As we keep adding more processes that get scheduled to different cores we&rsquo;re seeing the CPU usage go up even further, however with more processes comes more overhead for process scheduling (versus thread scheduling). We&rsquo;re still wasting CPU cycles, but we&rsquo;re completing 150,000 jobs in 98 seconds.</p>

<h3 id="sidekiq-jruby-50-threads">Sidekiq (JRuby) 50 threads</h3>


<figure >
    
        <img src="/images/showdown/jruby_50.png" />
    
    
</figure>


<p>We&rsquo;re doing much better now with native threads. With 50 OS level threads, we&rsquo;re completing our set of jobs in 91 seconds.</p>

<h3 id="sidekiq-jruby-150-threads-240-threads">Sidekiq (JRuby) 150 threads &amp; 240 Threads</h3>

<p>
<figure >
    
        <img src="/images/showdown/jruby_150.png" />
    
    
</figure>


<figure >
    
        <img src="/images/showdown/jruby_240.png" />
    
    
</figure>
</p>

<p>We&rsquo;re no longer seeing a increase in (much) CPU usage and only a slight decrease in processing time. As we keep adding more and more threads we end up running into some thread contention issues with accessing redis and how quickly we can pop things off the queue.</p>

<h1 id="overview">Overview</h1>

<p>Even if we stick with the stock MRI ruby and go with Sidekiq, we&rsquo;re going to see a huge decrease in CPU usage while also gaining a little bit of performance as well.</p>

<p>Sidekiq, overall, provides a cleaner, more object oriented interface (in my opinion) to inspecting jobs and what is going on in the processing queue.</p>

<p>In Resque you would do something like: <code>Resque.size(&quot;queue_name&quot;)</code>. However, in Sidekiq you would take your class, in this case, <code>POR</code> and call <code>POR.jobs</code> to get the list of jobs for that worker queue. (note: you need to <code>require 'sidekiq/testing'</code> to get access to the jobs method).</p>

<p>The only thing I find missing from Sidekiq that I enjoyed in Resque was the ability to inspect failed jobs in the web UI. However Sidekiq more than makes up for that with the ability to automatically retry failed jobs (although be careful you don&rsquo;t introduce race conditions and accidentally DOS yourself).</p>

<p>And of course, JRuby comes out on top and gives us the best performance and bang for the buck (although your mileage may vary, depending on the task).</p>

<h1 id="further-reading">Further Reading</h1>

<p><a href="http://www.amazon.com/gp/product/1934356972/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1934356972&linkCode=as2&tag=josren-20">Deploying with JRuby: Deliver Scalable Web Apps using the JVM (Pragmatic Programmers)</a><img src="http://www.assoc-amazon.com/e/ir?t=josren-20&l=as2&o=1&a=1934356972" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<p><a href="http://www.amazon.com/gp/product/B005SNJF28/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B005SNJF28&linkCode=as2&tag=josren-20">JRuby Cookbook</a><img src="http://www.assoc-amazon.com/e/ir?t=josren-20&l=as2&o=1&a=B005SNJF28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<h1 id="sidekiq-resque">Sidekiq &amp; Resque</h1>

<p><a href="https://github.com/mperham/sidekiq">Sidekiq</a></p>

<p><a href="https://github.com/defunkt/resque">Resque</a></p>
 </div>
      <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
</div>

  </div>

</footer>


  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'bluescripts';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>
  Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




    </article>
  </div>
  <div class="sidebar">
  <section>
    <h1>Projects & Software</h1>
    <ul>
      <li><a href="https://github.com/joshrendek/docker-conductor">Docker Conductor</a> is a docker orchestration tool.</li>
      <li><a href="http://sshpot.com/">sshpot.com</a> is a SSH honeypot service written in Go (both web service and client are open source).</li>
      <li><a href="http://ifcfg.net/">ifcfg.net</a> is a simple 'what is my IP' service with a few extra RESTful endpoints.</li>

      <li><a href="/projects/">View More</a>

      <li><a href="https://github.com/joshrendek?tab=repositories"><img src="/images/github.png" style='border: none;'> More on GitHub</a></li>
      <li><a href="https://rubygems.org/profiles/joshrendek">Gems @ RubyGems</a></li>
    </ul>
  </section>

  <section>
    <h1>Other Blogs</h1>
    <ul>
      <li><a href="http://tendermeatlove.com">Tender Meat Love</a> is my blog about cooking.</li>
      <li><a href="http://hydronerd.com">Hydro Nerd</a> is my blog about hydroponics and gardening.</li>
    </ul>
  </section>

  <section>
    <h1>Recent Posts</h1>
    <ul>
      
      <li><a href="https://joshrendek.com/2016/06/building-honeypots-and-analyzing-linux-malware/">Building honeypots and analyzing linux malware</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/understanding-elasticsearch-performance/">Understanding ElasticSearch Performance</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/">Building a distributed WaitGroup with Go and Redis</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/">Docker and ping: sendmsg: Operation not permitted</a></li>
      
      <li><a href="https://joshrendek.com/2015/10/influx-alert/">Influx Alert</a></li>
      
    </ul>
  </section>

</div>

</main>
  <footer>

  <div class="social-links-footer">

  

  

  

  

  

  <div class="social-link">
  <a href="https://joshrendek.com/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> © Copyright 2008-2017 Josh Rendek </div>

  </footer>

</body>
</html>

