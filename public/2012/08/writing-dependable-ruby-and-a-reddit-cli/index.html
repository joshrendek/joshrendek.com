<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8" />
<meta name="author" content="" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.25.1" />

<meta property="og:title" content="Writing Dependable Ruby &amp; a Reddit CLI" />
<meta property="og:description" content="View Source on Github 
When you work on your code and are finished for the day, is what you have committed worry free? If another developer were to push your code in the middle of the night, would they be calling you at 3am?
Let&rsquo;s see how we can improve our development cycle with testing so we can avoid those early morning calls. We&rsquo;ll go over some of the basics with a simple project to start." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://joshrendek.com/2012/08/writing-dependable-ruby-and-a-reddit-cli/" />



<meta property="article:published_time" content="2012-08-20T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2012-08-20T00:00:00&#43;00:00"/>













  <meta name="twitter:card" content="summary"/>



<meta name="twitter:text:title" content="Writing Dependable Ruby &amp; a Reddit CLI"/>
<meta name="twitter:title" content="Writing Dependable Ruby &amp; a Reddit CLI"/>
<meta name="twitter:description" content="View Source on Github 
When you work on your code and are finished for the day, is what you have committed worry free? If another developer were to push your code in the middle of the night, would they be calling you at 3am?
Let&rsquo;s see how we can improve our development cycle with testing so we can avoid those early morning calls. We&rsquo;ll go over some of the basics with a simple project to start."/>




<meta itemprop="name" content="Writing Dependable Ruby &amp; a Reddit CLI">
<meta itemprop="description" content="View Source on Github 
When you work on your code and are finished for the day, is what you have committed worry free? If another developer were to push your code in the middle of the night, would they be calling you at 3am?
Let&rsquo;s see how we can improve our development cycle with testing so we can avoid those early morning calls. We&rsquo;ll go over some of the basics with a simple project to start.">


<meta itemprop="dateModified" content="2012-08-20T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1405">



<meta itemprop="keywords" content="" />


<link rel="stylesheet" type="text/css" href="/css/layout.css" />
<link rel="stylesheet" type="text/css" href="/css/pygments.css" />
<link rel="stylesheet" type="text/css" href="/css/color-dark.css" />


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-3754808-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


<title>


     Writing Dependable Ruby &amp; a Reddit CLI 

</title>

<script src="/js/highlight.min.js"></script>
<link rel="stylesheet" href="/css/tomorrow-night.min.css" />
<script>hljs.initHighlightingOnLoad();</script>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://joshrendek.com">
        <span class='blue-brace'>{</span>
        Josh Rendek
        <span class='blue-brace'>}</span>
      </a>
      <div class="header-subtitle">
        <h2>
          <span class="heart">&lt;3</span> Ruby &amp; Go
        </h2>
      </div>
    </div> 
  </nav>
  <nav>
      
      
      <a class="nav-item" href="/"><div class="nav-item-title">Home</div></a>
      
      <a class="nav-item" href="/projects/"><div class="nav-item-title">Projects</div></a>
      
      <a class="nav-item" href="/archives/"><div class="nav-item-title">Archives</div></a>
      
      <a class="nav-item" href="https://devopsbyvideo.com/"><div class="nav-item-title">Screen Casts</div></a>
      
      <a class="nav-item" href="/about/"><div class="nav-item-title">About</div></a>
      
      <a class="nav-item" href="/categories/"><div class="nav-item-title">Categories</div></a>
      
      <a class="nav-item" href="https://github.com/joshrendek/"><div class="nav-item-title">GitHub</div></a>
      
      <a class="nav-item" href="/resume.pdf"><div class="nav-item-title">Resume</div></a>
      
   </nav>
</div>

  
<div class="social-links-header">

  

  

  

  

  

</div>


</header>


<main>
  <div class="articles">
    <article class="post">
      <div class="date"> Aug 20, 2012 - 7 minutes</div>
      <h1 class="title"> Writing Dependable Ruby &amp; a Reddit CLI </h1>
      <div class="content"> 

<p><center>
    <a href="https://github.com/bluescripts/reddit-cli">View Source on Github</a>
</center></p>

<p>When you work on your code and are finished for the day, is what you have committed worry free? If another developer were to push your code in the middle of the night, would they be calling you at 3am?</p>

<p>Let&rsquo;s see how we can improve our development cycle with testing so we can avoid those early morning calls. We&rsquo;ll go over some of the basics with a simple project to start.</p>

<p>The most important part about TDD is getting quick feedback based on our desired design (the feedback loop).</p>

<p>Here is an example of how fast the tests run:
<object width="640" height="480"><param name="movie" value="http://www.youtube.com/v/GFQMT246FOg?version=3&amp;hl=en_US&hd=1"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/GFQMT246FOg?version=3&amp;hl=en_US&hd=1" type="application/x-shockwave-flash" width="640" height="480" allowscriptaccess="always" allowfullscreen="true"></embed></object></p>

<p>While this is a somewhat contrived example for the reddit cli we&rsquo;re making, this can be applied equally as well when writing Rails applications. Only load the parts you need (ActionMailer, ActiveSupport, etc), usually you don&rsquo;t need to load the entire rails stack. This can make your tests run in milliseconds instead of seconds. This lets you get feedback right away.</p>

<p>Before we go further into the testing discussion, lets setup a spec helper.</p>

<p>{% codeblock spec/spec_helper.rb lang:ruby %}
require &lsquo;rspec&rsquo;
require &lsquo;vcr&rsquo;
require &lsquo;pry&rsquo;
VCR.configure do |c|
  c.cassette_library_dir = &lsquo;fixtures/vcr_cassettes&rsquo;
  c.hook_into :fakeweb# or :fakeweb
end
{% endcodeblock %}</p>

<p>Now how do we start doing TDD? We first start with a failing test.</p>

<p>{% codeblock Reddit API Spec (Pass 1) - spec/lib/reddit_api_spec lang:ruby %}
require &lsquo;spec_helper&rsquo;
require &lsquo;./lib/reddit_api&rsquo;</p>

<p>describe RedditApi do
    let(:reddit) { RedditApi.new(&lsquo;ProgrammerHumor&rsquo;) }
    context &ldquo;#initializing&rdquo; do
        it &ldquo;should form the correct endpoint&rdquo; do
            reddit.url.should eq &ldquo;<a href="http://reddit.com/r/ProgrammerHumor/.json?after=&quot;">http://reddit.com/r/ProgrammerHumor/.json?after=&quot;</a>
        end
    end
end
{% endcodeblock %}</p>

<p>When we create a new instance of the Reddit API we want to pass it a subreddit, and then we want to make sure it builds the URL properly.</p>

<p>{% codeblock Reddit API (Pass 1) - lib/reddit_api.rb lang:ruby %}
require &lsquo;json&rsquo;
require &lsquo;rest-client&rsquo;</p>

<p>class RedditApi
    REDDIT_URL = &ldquo;<a href="http://reddit.com/r/&quot;">http://reddit.com/r/&quot;</a>
    attr_reader :url, :stories
    def initialize(subreddit)
        @subreddit = subreddit
        @after = &ldquo;&rdquo;
        @url = &ldquo;#{REDDIT_URL}#{subreddit}/.json?after=#{@after}&rdquo;
    end
end
{% endcodeblock %}</p>

<p>Next we want to make the actual HTTP request to the Reddit api and process it.</p>

<p>{% codeblock Reddit API Spec (Pass 2) - spec/lib/reddit_api_spec lang:ruby %}
require &lsquo;spec_helper&rsquo;
require &lsquo;./lib/reddit_api&rsquo;</p>

<p>describe RedditApi do
    let(:reddit) { RedditApi.new(&lsquo;ProgrammerHumor&rsquo;) }
    context &ldquo;#initializing&rdquo; do
        it &ldquo;should form the correct endpoint&rdquo; do
            VCR.use_cassette(&lsquo;reddit_programmer_humor&rsquo;) do
                reddit.url.should eq &ldquo;<a href="http://reddit.com/r/ProgrammerHumor/.json?after=&quot;">http://reddit.com/r/ProgrammerHumor/.json?after=&quot;</a>
            end
        end
    end</p>

<pre><code>context &quot;#fetching&quot; do
    it &quot;should fetch the first page of stories&quot; do
        VCR.use_cassette('reddit_programmer_humor') do
            reddit.stories.count.should eq(25)
        end
    end
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>We&rsquo;ve now added a VCR wrapper and added an expectation that the reddit api will return a list of stories. We use VCR here to again ensure that our tests run fast. Once we make the first request, future runs will take milliseconds and will hit our VCR tape instead of the API.</p>

<p>Now we need to introduce three new areas: requesting, processing, and a Story object class.</p>

<p>{% codeblock Story - lib/story.rb lang:ruby %}
Story = Struct.new(:title, :score, :comments, :url)
{% endcodeblock %}</p>

<p>{% codeblock Reddit API (Pass 2) - lib/reddit_api.rb lang:ruby %}
require &lsquo;json&rsquo;
require &lsquo;rest-client&rsquo;
require &lsquo;./lib/story&rsquo;</p>

<p>class RedditApi
    REDDIT_URL = &ldquo;<a href="http://reddit.com/r/&quot;">http://reddit.com/r/&quot;</a>
    attr_reader :url, :stories
    def initialize(subreddit)
        @subreddit = subreddit
        @after = &ldquo;&rdquo;
        @url = &ldquo;#{REDDIT_URL}#{subreddit}/.json?after=#{@after}&rdquo;
        request
        process_request
    end</p>

<pre><code>def request
    @request_response = JSON.parse(RestClient.get(@url))
end

def process_request
    @stories = []
    @request_response['data']['children'].each do |red|
        d = red['data']
        @stories &lt;&lt; Story.new(d['title'], d['score'],
                              d['num_comments'], d['url'])
    end
    @after = @request_response['data']['after']
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>What can we do now? The API lets us make a full request and get a list of Story struct objects back. We&rsquo;ll be using this array of structs later on to build the CLi.</p>

<p>The only thing left for this simple CLI a way to get to the next page. Let&rsquo;s add our failing spec:</p>

<p>{% codeblock Reddit API Spec (Pass 3) - spec/lib/reddit_api_spec lang:ruby %}
require &lsquo;spec_helper&rsquo;
require &lsquo;./lib/reddit_api&rsquo;</p>

<p>describe RedditApi do
    let(:reddit) { RedditApi.new(&lsquo;ProgrammerHumor&rsquo;) }
    context &ldquo;#initializing&rdquo; do
        it &ldquo;should form the correct endpoint&rdquo; do
            VCR.use_cassette(&lsquo;reddit_programmer_humor&rsquo;) do
                reddit.url.should eq &ldquo;<a href="http://reddit.com/r/ProgrammerHumor/.json?after=&quot;">http://reddit.com/r/ProgrammerHumor/.json?after=&quot;</a>
            end
        end
    end</p>

<pre><code>context &quot;#fetching&quot; do
    it &quot;should fetch the first page of stories&quot; do
        VCR.use_cassette('reddit_programmer_humor') do
            reddit.stories.count.should eq(25)
        end
    end

    it &quot;should fetch the second page of stories&quot; do
        VCR.use_cassette('reddit_programmer_humor_p2') do
            reddit.next.stories.count.should eq(25)
        end
    end
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>And let&rsquo;s make the test pass:</p>

<p>{% codeblock Reddit API (Pass 3) - lib/reddit_api.rb lang:ruby %}
require &lsquo;json&rsquo;
require &lsquo;rest-client&rsquo;
require &lsquo;./lib/story&rsquo;</p>

<p>class RedditApi
    REDDIT_URL = &ldquo;<a href="http://reddit.com/r/&quot;">http://reddit.com/r/&quot;</a>
    attr_reader :url, :stories
    def initialize(subreddit)
        @subreddit = subreddit
        @after = &ldquo;&rdquo;
        @url = &ldquo;#{REDDIT_URL}#{subreddit}/.json?after=#{@after}&rdquo;
        request
        process_request
    end</p>

<pre><code>def next
    @url = &quot;#{REDDIT_URL}#{@subreddit}/.json?after=#{@after}&quot;
    request
    process_request
    self
end

def request
    @request_response = JSON.parse(RestClient.get(@url))
end

def process_request
    @stories = []
    @request_response['data']['children'].each do |red|
        d = red['data']
        @stories &lt;&lt; Story.new(d['title'], d['score'],
                              d['num_comments'], d['url'])
    end
    @after = @request_response['data']['after']
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>We also allow method chaining since we return self after calling next (so you could chain next&rsquo;s for instance).</p>

<p>Another important principal to keep in mind is the &ldquo;Tell, Dont Ask&rdquo; rule. Without tests, we might have gone this route:</p>

<p>{% codeblock bad_example.rb lang:ruby %}
@reddit = Reddit.new(&lsquo;ProgrammerHumor&rsquo;)</p>

<h1 id="user-presses-next">User presses next</h1>

<p>@reddit.url = &ldquo;<a href="http://reddit.com/r/ProgrammerHumor/.json?after=sometoken&quot;">http://reddit.com/r/ProgrammerHumor/.json?after=sometoken&quot;</a>
{% endcodeblock %}</p>

<p>Not only would we not be telling the object what we want, we would be modifying the internal state of an object as well. By implementing a <code>next</code> method we abstract the idea of a URL and any tokens we may need to keep track of away from the consumer. Doing TDD adds a little extra step of &ldquo;Thinking&rdquo; more about what we want our interfaces to be. What&rsquo;s easier? Calling <code>next</code> or modifying the internal state?</p>

<p>I&rsquo;m kind of cheating a bit here. I found a nice &ldquo;table&rdquo; gem that outputs what you send in as a formatted table (think MySQL console output). Let&rsquo;s just make sure everything is being sent around properly and STDOUT is printing the correct contents:</p>

<p>{% codeblock Reddit CLI Spec (Pass 1) - spec/lib/reddit-cli.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;
require &lsquo;stringio&rsquo;
require &lsquo;./lib/reddit-cli&rsquo;</p>

<p>describe RedditCli do
    let(:subreddit) { &ldquo;ProgrammerHumor&rdquo; }
    context &ldquo;#initializing&rdquo; do
        before(:all) do
            $stdout = @fakeout = StringIO.new
        end</p>

<pre><code>    it &quot;should print out a story&quot; do
        api_response = double(RedditApi)
        api_response.stub!(:stories =&gt;
                           [Story.new(&quot;StoryTitle&quot;, &quot;Score&quot;,
                                      &quot;Comments&quot;, &quot;URL&quot;)])
        $stdin.should_receive(:gets).and_return(&quot;q&quot;)
        cli = RedditCli.new(api_response)
        $stdout = STDOUT
        @fakeout.string.include?('StoryTitle').should be_true
    end
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>We&rsquo;re doing several things here. First we&rsquo;re taking <code>$stdout</code> and putting it (temporarily) into a instance variable so we can see what gets outputted. Next we&rsquo;re mocking out the <code>RedditApi</code> since we dont actually need to hit that class or the VCR tapes, we just need to stub out the expected results (stories) and pass the response object along to the CLI class. And finally once we&rsquo;re finished we set <code>$stdout</code> back to the proper constant.</p>

<p>And the class for output:</p>

<p>{% codeblock Reddit CLI (Pass 1) - lib/reddit-cli.rb lang:ruby %}
require &lsquo;./lib/reddit_api&rsquo;
require &lsquo;terminal-table&rsquo;
class RedditCli
    def initialize(api)
        @rows = []
        @api = api
        @stories = api.stories
        print_stories
        print &ldquo;\nType ? for help\n&rdquo;
        prompt
    end</p>

<pre><code>def print_stories
    @stories.each_with_index {|x, i| @rows &lt;&lt; [i, x.score, x.comments, x.title[0..79] ] }
    puts Terminal::Table.new :headings=&gt; ['#', 'Score', 'Comments', 'Title'], :rows =&gt; @rows
end

def prompt
    print &quot;\n?&gt; &quot;
    input = STDIN.gets.chomp
    case input
    when &quot;?&quot;
        p &quot;Type the # of a story to open it in your browser&quot;
        p &quot;Type n to go to the next page&quot;
        prompt
    when &quot;quit&quot;, &quot;q&quot;
    when &quot;n&quot;
        @rows = []
        @stories = @api.next.stories
        print_stories
        prompt
    else
        print &quot;#=&gt; Oepning: #{@stories[input.to_i].url}&quot;
        `open #{@stories[input.to_i].url}`
        prompt
    end
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>And finally, a little wrapper in the root directory:</p>

<p>{% codeblock Wrapper - reddit-cli.rb lang:ruby %}
require &lsquo;./lib/reddit_api&rsquo;
require &lsquo;./lib/reddit-cli&rsquo;</p>

<p>subreddit = ARGV[0]
RedditCli.new(RedditApi.new(subreddit))
{% endcodeblock %}</p>

<h2 id="an-important-note">An Important Note</h2>

<p>When working with external resources, whether it be a gem or a remote API, it&rsquo;s important to wrap those endpoints in your own abstraction. For instance, with our Reddit CLI we could have avoided those first 2 classes entirely, written everything in the CLI display class, and worked with the raw JSON. But what happens when Reddit changes their API? If this CLI class was huge or incoporated many other components, this could be quite a big code change. Instead, what we wrote encapsulates the API inside a <code>RedditApi</code> class that returns a generic <code>Story</code> struct we can work with and pass around. We don&rsquo;t care if the API changes in the CLI, or in any other code. If the API changes, we only have to update the one API class to mold the new API to the output we were already generating.</p>

<h2 id="end-result-amp-source-code">End Result  &amp; Source Code</h2>

<p><img src="https://img.skitch.com/20120821-bc2b49nued2e38tt3cekppeq1i.jpg"></p>

<p><center>
    <a href="https://github.com/bluescripts/reddit-cli">View Source on Github</a>
</center></p>
 </div>
      <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
</div>

  </div>

</footer>


  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'bluescripts';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>
  Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




    </article>
  </div>
  <div class="sidebar">
  <section>
    <h1>Projects & Software</h1>
    <ul>
      <li><a href="https://github.com/joshrendek/docker-conductor">Docker Conductor</a> is a docker orchestration tool.</li>
      <li><a href="http://sshpot.com/">sshpot.com</a> is a SSH honeypot service written in Go (both web service and client are open source).</li>
      <li><a href="http://ifcfg.net/">ifcfg.net</a> is a simple 'what is my IP' service with a few extra RESTful endpoints.</li>

      <li><a href="/projects/">View More</a>

      <li><a href="https://github.com/joshrendek?tab=repositories"><img src="/images/github.png" style='border: none;'> More on GitHub</a></li>
      <li><a href="https://rubygems.org/profiles/joshrendek">Gems @ RubyGems</a></li>
    </ul>
  </section>

  <section>
    <h1>Other Blogs</h1>
    <ul>
      <li><a href="http://tendermeatlove.com">Tender Meat Love</a> is my blog about cooking.</li>
      <li><a href="http://hydronerd.com">Hydro Nerd</a> is my blog about hydroponics and gardening.</li>
    </ul>
  </section>

  <section>
    <h1>Recent Posts</h1>
    <ul>
      
      <li><a href="https://joshrendek.com/2016/06/building-honeypots-and-analyzing-linux-malware/">Building honeypots and analyzing linux malware</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/understanding-elasticsearch-performance/">Understanding ElasticSearch Performance</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/building-a-distributed-waitgroup-with-go-and-redis/">Building a distributed WaitGroup with Go and Redis</a></li>
      
      <li><a href="https://joshrendek.com/2015/11/docker-and-ping-sendmsg-operation-not-permitted/">Docker and ping: sendmsg: Operation not permitted</a></li>
      
      <li><a href="https://joshrendek.com/2015/10/influx-alert/">Influx Alert</a></li>
      
    </ul>
  </section>

</div>

</main>
  <footer>

  <div class="social-links-footer">

  

  

  

  

  

  <div class="social-link">
  <a href="https://joshrendek.com/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright"> © Copyright 2008-2017 Josh Rendek </div>

  </footer>

</body>
</html>

