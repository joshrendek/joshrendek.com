<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Go | Josh Rendek]]></title>
  <link href="http://joshrendek.com/categories/go/atom.xml" rel="self"/>
  <link href="http://joshrendek.com/"/>
  <updated>2016-12-15T16:05:34-05:00</updated>
  <id>http://joshrendek.com/</id>
  <author>
    <name><![CDATA[Josh Rendek]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go-lang Compare *ssh.Request.Type Against a String]]></title>
    <link href="http://joshrendek.com/2014/07/go-lang-compare-star-ssh-dot-request-dot-type-against-a-string/"/>
    <updated>2014-07-08T08:34:00-04:00</updated>
    <id>http://joshrendek.com/2014/07/go-lang-compare-star-ssh-dot-request-dot-type-against-a-string</id>
    <content type="html"><![CDATA[<p>I was working on the agent for <a href="http://sshpot.com/">SSH Pot</a> and ran into something interesting last night. A lot of the brute force attempts attempt to run a command like this:</p>

<pre><code class="bash Example Exec">ssh user@host 'uname'
</code></pre>

<p>This is different than:</p>

<pre><code class="bash Example Shell">ssh user@host
$ uname
</code></pre>

<p>The first command is executing a command then exiting, the second is actually logging in and giving the user a shell. The first requests a exec subsystem and the second requests a shell subsystem - so there are two ways to handle it.</p>

<pre><code class="go broken_handler.go">func HandleShellRequest(channel ssh.Channel, in &lt;-chan *ssh.Request) {
    for req := range in {
        ok := true
        logfile.Println("[request " + req.Type + "]: " + string(req.Payload))
        switch req.Type {
        case "shell":
            req.Reply(ok, nil)
        case "exec":
            if string(req.Payload) == string("uname") {
                channel.Write([]byte("\n\rLinux\n\r"))
            }

            channel.Close()
        }
    }
}
</code></pre>

<p>When logging in my logfile it would show something like:</p>

<p><code>bash Log
</code></p>

<p>And even when comparing the two side by side with something like this:</p>

<pre><code class="go log.go">logfile.Println("["+string(req.Payload)+"]:["+"uname"+"]")
</code></pre>

<p>I would get this output:</p>

<p><code>bash Log
</code></p>

<p>Yet the comparison on line 9 would not get hit. After sitting and thinking about it for a while I decided to print the bytes out:</p>

<pre><code class="bash Log">INFO: 2014/07/07 23:15:18 sshd.go:157: [0 0 0 5 117 110 97 109 101]
INFO: 2014/07/07 23:15:18 sshd.go:158: [117 110 97 109 101]
</code></pre>

<p>Aha! So for some reason req.Payload is padded with 3 null bytes and a ENQ byte (hex 5).</p>

<p>Here is the corrected version removing the correct bytes - now the string comparison works:</p>

<pre><code class="go working_handler.go">func HandleShellRequest(channel ssh.Channel, in &lt;-chan *ssh.Request) {
    for req := range in {
        ok := true
        logfile.Println("[request " + req.Type + "]: " + string(req.Payload))
        switch req.Type {
        case "shell":
            req.Reply(ok, nil)
        case "exec":
            if string(req.Payload[4:]) == string("uname") {
                channel.Write([]byte("\n\rLinux\n\r"))
            }

            channel.Close()
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go-lang: Mocking exec.Command Using Interfaces]]></title>
    <link href="http://joshrendek.com/2014/06/go-lang-mocking-exec-dot-command-using-interfaces/"/>
    <updated>2014-06-18T20:53:00-04:00</updated>
    <id>http://joshrendek.com/2014/06/go-lang-mocking-exec-dot-command-using-interfaces</id>
    <content type="html"><![CDATA[<p>This is a short example showing how to use an interface to ease testing, and how to use an interface with running shell commands / other programs and providing mock output.</p>

<center>
<a href="https://github.com/joshrendek/go-exec-mock-example">Source on Github</a>
</center>


<p>Here is our main file that actually runs the commands and prints out &ldquo;hello&rdquo;.</p>

<pre><code class="go example.go">package main

import (
    "fmt"
    "os/exec"
)

// first argument is the command, like cat or echo,
// the second is the list of args to pass to it
type Runner interface {
    Run(string, ...string) ([]byte, error)
}

type RealRunner struct{}

var runner Runner

// the real runner for the actual program, actually execs the command
func (r RealRunner) Run(command string, args ...string) ([]byte, error) {
    out, err := exec.Command(command, args...).CombinedOutput()
    return out, err
}

func Hello() string {
    out, err := runner.Run("echo", "hello")
    if err != nil {
        panic(err)
    }
    return string(out)
}

func main() {
    runner = RealRunner{}
    fmt.Println(Hello())
}
</code></pre>

<p>Here is our test file. We start by defining our <code>TestRunner</code> type and implementing the <code>Run(...)</code> interface for it.</p>

<p>This function builds up a command to run the current test file and run the <code>TestHelperProcess</code> function passing along all the args you originally sent. This lets you do things like return different output for different commands you want to run.</p>

<p>The <code>TestHelperProcess</code> function exits when run in the context of the test file, but runs when specified in the files arguments.</p>

<pre><code class="go example_test.go">package main

import (
    "fmt"
    "os"
    "os/exec"
    "testing"
)

type TestRunner struct{}

func (r TestRunner) Run(command string, args ...string) ([]byte, error) {
    cs := []string{"-test.run=TestHelperProcess", "--"}
    cs = append(cs, args...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
    out, err := cmd.CombinedOutput()
    return out, err
}

func TestHello(t *testing.T) {
    runner = TestRunner{}
    out := Hello()
    if out == "testing helper process" {
        t.Logf("out was eq to %s", string(out))
    }
}

func TestHelperProcess(*testing.T) {
    if os.Getenv("GO_WANT_HELPER_PROCESS") != "1" {
        return
    }
    defer os.Exit(0)
    fmt.Println("testing helper process")
}
</code></pre>

<p>Hopefully this helps someone else! I had a hard time finding some good, short examples on the internet that combined both interfaces and mocking like this.</p>

<center>
<a href="http://golang.org/src/pkg/os/exec/exec_test.go">More examples from os/exec/exec_test.go</a>
</center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Useful Logger in Go]]></title>
    <link href="http://joshrendek.com/2014/06/a-useful-logger-in-go/"/>
    <updated>2014-06-09T21:26:00-04:00</updated>
    <id>http://joshrendek.com/2014/06/a-useful-logger-in-go</id>
    <content type="html"><![CDATA[<p>Small function that will print out useful information when invoked:</p>

<pre><code class="go log.go">func logMsg(msg string) {
    pc, _, _, _ := runtime.Caller(1)
    caller := runtime.FuncForPC(pc).Name()
    _, file, line, _ := runtime.Caller(0)
    sp := strings.Split(file, "/")
    short_path := sp[len(sp)-2 : len(sp)]
    path_line := fmt.Sprintf("[%s/%s:%d]", short_path[0], short_path[1], line)
    log_string := fmt.Sprintf("[%s]%s %s:: %s", time.Now(), path_line, caller, msg)
    fmt.Println(log_string)
}
</code></pre>

<p>Sample output:
<code>text
[2014-06-10 01:38:45.812215998 +0000 UTC][src/trex-client.go:15]{main.main}:: checking jobs - finish
[2014-06-10 01:38:47.329650331 +0000 UTC][src/trex-client.go:15]{main.main}:: building package list - start
</code></p>
]]></content>
  </entry>
  
</feed>
