<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Refactoring | Josh Rendek]]></title>
  <link href="http://joshrendek.com/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://joshrendek.com/"/>
  <updated>2016-12-15T16:05:34-05:00</updated>
  <id>http://joshrendek.com/</id>
  <author>
    <name><![CDATA[Josh Rendek]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2 Patterns for Refactoring With Your Ruby Application]]></title>
    <link href="http://joshrendek.com/2013/11/2-patterns-for-refactoring-with-your-ruby-application/"/>
    <updated>2013-11-15T21:55:00-05:00</updated>
    <id>http://joshrendek.com/2013/11/2-patterns-for-refactoring-with-your-ruby-application</id>
    <content type="html"><![CDATA[<p>When working on a rails application you can sometimes find duplicated or very similar code between two different controllers (for instance a UI element and an API endpoint).
Realizing that you have this duplication there are several things you can do. I&rsquo;m going to go over how to extract this code out into the
query object pattern <sup><a href="http://www.martinfowler.com/eaaCatalog/queryObject.html">1</a></sup>
and clean up our constructor using the builder pattern <sup><a href="http://en.wikipedia.org/wiki/Builder_pattern">2</a></sup> adapted to ruby.</p>

<p>I&rsquo;m going to make a few assumptions here, but this should be applicable to any
data access layer of your application. I&rsquo;m also assuming you&rsquo;re using something like Kaminari for pagination and have a model
for <code>People</code>.</p>

<pre><code class="ruby dummy_controller.rb">
def index
  page = params[:page] || 1
  per_page = params[:per_page] || 50
  name = params[:name]
  sort = params[:sort_by] || 'last_name'
  direction = params[:sort_direction] || 'asc'

  query = People
  query = query.where(name: name) if name.present?
  @results = query.order("#{sort} #{direction}").page(page).per_page(per_page)
end
</code></pre>

<p>So we see this duplicated elsehwere in the code base and we want to clean it up. Lets first start by extracting this out into a new class called <code>PeopleQuery</code>.</p>

<p>I usually put these under <code>app/queries</code> in my rails application.</p>

<pre><code class="ruby people_query.rb">
class PeopleQuery
  attr_accessor :page, :per_page, :name, :sort, :direction, :query
  def initialize(page, per_page, name, sort, direction)
    self.page = page || 1
    self.per_page = per_page || 50
    self.name = name
    self.sort = sort || 'last_name'
    self.direction = direction || 'asc'
    self.query = People
  end

  def build
    self.query = self.query.where(name: self.name) if self.name.present?
    self.query.order("#{self.sort} #{self.direction}").page(self.page).per_page(self.per_page)
  end
end
</code></pre>

<p>Now our controller looks like this:</p>

<pre><code class="ruby dummy_controller.rb">
def index
  query = PeopleQuery.new(params[:page], params[:per_page], params[:name], params[:sort], params[:direction])
  @results = query.build
end
</code></pre>

<p>Much better! We&rsquo;ve decoupled our control from our data access object (<code>People</code>/ActiveRecord), moved some of the query logic outside of the controller and into
a specific class meant to deal with building it. But that constructor doesn&rsquo;t look very nice. We can do better since we&rsquo;re using ruby.</p>

<p>Our new <code>PeopleQuery</code> class will look like this and will use a block to initialize itself instead of a long list of constructor arguments.</p>

<pre><code>class PeopleQuery
  attr_accessor :page, :per_page, :name, :sort, :direction, :query
  def initialize(&amp;block)
    yield self
    self.page ||= 1
    self.per_page =|| 50
    self.sort ||= 'last_name'
    self.direction ||= 'asc'
    self.query = People
  end

  def build
    self.query = self.query.where(name: self.name) if self.name.present?
    self.query.order("#{self.sort} #{self.direction}").page(self.page).per_page(self.per_page)
  end
end
</code></pre>

<p>We yield first to let the caller set the values and then after yielding we set our default values if they weren&rsquo;t passed in. There is another method of doing this
with <code>instance_eval</code> but you end up losing variable scope and the constructor looks worse since you have to start passing around the params variable to get access to it, so we&rsquo;re
going to stick with yield.</p>

<pre><code class="ruby dummy_controller.rb">
def index
  query = PeopleQuery.new do |query|
    query.page = params[:page]
    query.per_page = params[:per_page]
    query.name = params[:name]
    query.sort = params[:sort]
    query.direction = params[:direction]
  end
  @results = query.build
end
</code></pre>

<p>And that&rsquo;s it! We&rsquo;ve de-duplicated some code (remember we assumed dummy controller&rsquo;s index method was duplicated elsewhere in an API call in a seperate namespaced controller),
extracted out a common query object, decoupled our controller from ActiveRecord, and built up a nice way to construct the query object using the builder pattern.</p>
]]></content>
  </entry>
  
</feed>
